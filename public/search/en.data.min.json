[{"id":0,"href":"/SystemAdministration/Cloud/","title":"Cloud","parent":"System Administration","content":"Demo collapsible menu entries. sss\n","description":"Demo collapsible menu entries. sss"},{"id":1,"href":"/SystemAdministration/","title":"System Administration","parent":"Softlockup","content":"Demo collapsible menu entries. sss\n","description":"Demo collapsible menu entries. sss"},{"id":2,"href":"/SystemAdministration/Windows/","title":"Windows","parent":"System Administration","content":"Demo collapsible menu entries. sss\n","description":"Demo collapsible menu entries. sss"},{"id":3,"href":"/SystemAdministration/Linux/","title":"Linux","parent":"System Administration","content":"Linux landing page\n","description":"Linux landing page"},{"id":4,"href":"/Networking/","title":"Networking","parent":"Softlockup","content":"Offline\n","description":"Offline"},{"id":5,"href":"/Cybersecurity/","title":"Cybersecurity","parent":"Softlockup","content":"Demo collapsible menu entries. sss\n","description":"Demo collapsible menu entries. sss"},{"id":6,"href":"/Automation/","title":"Automation","parent":"Softlockup","content":"Demo collapsible menu entries. sss\n","description":"Demo collapsible menu entries. sss"},{"id":7,"href":"/SystemAdministration/MacOS/","title":"MacOS","parent":"System Administration","content":"Demo collapsible menu entries. sss\n","description":"Demo collapsible menu entries. sss"},{"id":8,"href":"/SoftwareDevelopment/","title":"Software Development","parent":"Softlockup","content":"Demo collapsible menu entries. sss\n","description":"Demo collapsible menu entries. sss"},{"id":9,"href":"/SystemAdministration/Windows/How-to-Track-Registry-Key-Modifications-Using-Process-Monitor/","title":"How to Track Registry Key Modifications Using Process Monitor","parent":"Windows","content":"\rHow to Track Registry Key Modifications Using Process Monitor\rModifying registry keys is a common operation that can be performed by both system and user processes. But what happens when a registry key value changes unexpectedly, leading to system behavior that‚Äôs hard to diagnose? Knowing exactly which process modified a registry key can be invaluable in system administration and debugging scenarios. One powerful tool that can help you identify such changes in real-time is Sysinternals Process Monitor.\nPre-requisites\rA test VM or system where you have administrative rights Familiarity with PowerShell Step 1: Download Process Monitor\rUsing PowerShell\rIf your test VM has unrestricted internet access, you can use this PowerShell script to download and run Process Monitor:\n$downloadUrl = \u0026#34;https://download.sysinternals.com/files/ProcessMonitor.zip\u0026#34; $outputPath = \u0026#34;C:\\Temp\u0026#34; if (!(Test-Path -Path $outputPath -PathType Container)) { New-Item -Path $outputPath -ItemType Directory } Invoke-WebRequest -Uri $downloadUrl -OutFile \u0026#34;$outputPath\\ProcessMonitor.zip\u0026#34; Expand-Archive -Path \u0026#34;$outputPath\\ProcessMonitor.zip\u0026#34; -DestinationPath $outputPath -Force $processMonitorPath = Join-Path -Path $outputPath -ChildPath \u0026#34;Procmon.exe\u0026#34; Start-Process -FilePath $processMonitorPath -ArgumentList \u0026#39;/accepteula\u0026#39; Manual Download\rIf you prefer a manual approach, download Process Monitor from Microsoft\u0026rsquo;s website, unpack it to your chosen directory and double-click to run.\nStep 2: Prepare the Environment\rOnce Process Monitor is running, stop the logging of current activity by pressing Control+E. Clear the already captured events by pressing Control+X.\nStep 3: Set Up Filtering\rPress Control+L to open the filter settings dialog.\nAdd a filter to capture only registry-related events:\nFor ‚ÄúEvent class,‚Äù select Registry. Click ‚ÄúAdd. To focus on a particular registry path, add another filter:\nFor ‚ÄúPath,‚Äù switch the condition from ‚Äúis‚Äù to ‚Äúcontains‚Äù. Enter the path for which you want to capture events. For this example, we‚Äôll use HKLM\\SOFTWARE\\Policies\\Microsoft\\Windows\\WindowsUpdate\\AU. To make the logs easier to read, check the ‚ÄúDrop filtered events‚Äù option. This will prevent any filtered events from being recorded.\nStep 4: Test the Configuration (Optional)\rBefore capturing events related to your issue, test the setup:\n$regKeyPath = \u0026#34;HKLM:\\SOFTWARE\\Policies\\Microsoft\\Windows\\WindowsUpdate\\AU\u0026#34; $newValue = 1 if (Test-Path $regKeyPath) { Set-ItemProperty -Path $regKeyPath -Name \u0026#34;NoAutoUpdate\u0026#34; -Value $newValue Write-Host \u0026#34;Value of $regKeyPath\\NoAutoUpdate has been changed to $newValue\u0026#34; } else { Write-Host \u0026#34;Registry key $regKeyPath does not exist.\u0026#34; } Run this PowerShell script and verify that you see a RegSetValue event in Process Monitor. Once confirmed, clear the capture again by pressing Control+X.\nStep 5: Catch the Culprit\rStart the capture by pressing Control+E. Reproduce the issue you are facing and keep an eye out for RegSetValue events. These will indicate which process has modified the registry key.\n","description":"How to Track Registry Key Modifications Using Process Monitor\rModifying registry keys is a common operation that can be performed by both system and user processes. But what happens when a registry key value changes unexpectedly, leading to system behavior that‚Äôs hard to diagnose? Knowing exactly which process modified a registry key can be invaluable in system administration and debugging scenarios. One powerful tool that can help you identify such changes in real-time is Sysinternals Process Monitor."},{"id":10,"href":"/tags/sysadmin/","title":"Sysadmin","parent":"Tags","content":"","description":""},{"id":11,"href":"/tags/sysinternals/","title":"Sysinternals","parent":"Tags","content":"","description":""},{"id":12,"href":"/tags/","title":"Tags","parent":"Softlockup","content":"","description":""},{"id":13,"href":"/tags/windows/","title":"Windows","parent":"Tags","content":"","description":""},{"id":14,"href":"/tags/azure/","title":"Azure","parent":"Tags","content":"","description":""},{"id":15,"href":"/SystemAdministration/Windows/how-hyper-v-works-high-level-overview/","title":"How Hyper-V Works, High Level Overview","parent":"Windows","content":"\rHow Hyper-V Works, High Level Overview\rHyper-V stands as Microsoft‚Äôs first standalone hypervisor, offering extensive support for the x86-64 architecture. It has established its own space in the virtualization market, going toe-to-toe with competitors like VMware ESXi, Xen, and KVM. One of its distinct advantages is its native integration with Microsoft-centric environments.\nContrary to many Type 2 hypervisors that function atop an existing operating system, Hyper-V is a Type 1 hypervisor that interacts directly with the hardware. This distinction can lead to initial confusion, given that the setup starts with a customary Windows Server installation. However, once Hyper-V is activated as an additional role, the Windows Server OS converts into a privileged partition, coming under the immediate control of the hypervisor after a system reboot.\nIn the nomenclature of Microsoft, guest virtualized operating systems are designated as partitions. The architecture follows a hierarchical model where a privileged root partition holds the reins, governing all other child partitions. This root partition is entrusted with full hypervisor permissions and oversees the configuration and management of lesser-privileged guest partitions. It has access other partition‚Äôs physical memory.\n‚ÄúUnenlightened‚Äù operating systems (OSes that are unaware of their virtualized environment) can also operate smoothly on Hyper-V. This is accomplished by Hyper-V‚Äôs emulation of universally compatible standard devices, allowing these operating systems to function as if they were running on physical hardware.\nIn contrast, operating systems tailored for Hyper-V can use extra capabilities to boost performance. For example, these specialized systems have the ability to make Hypercalls, allowing them to interact directly with the hypervisor. Hypercalls work through publicly available Hyper-V APIs and serve a role similar to traditional system call interfaces present in operating system kernels.\nAdditionally, the VMBus framework in Hyper-V paves the way for quick and direct data exchanges between the root and child partitions. In default configuration VMBus communication is allowed only between guest and root partitions. This feature is particularly beneficial for synthetic devices, which outperform their emulated equivalents in speed. A noteworthy instance of such an optimized device operating in an enlightened partition is Azure‚Äôs Accelerated Networking feature. We will discuss the difference between emulated vs synthetic devices in ‚ÄúTypes of Virtual Devices in Hyper-V‚Äù section.\nMemory Virtualization\rHyper-V is using EPT (Extended Page Tables) that serves as an additional layer of memory virtualization, enabling more direct and efficient mapping between the guest‚Äôs virtual memory and the host‚Äôs physical memory. The EPT feature uses its own set of tables (similar to page tables in standard memory management) to map the guest‚Äôs physical address space directly to the host‚Äôs physical address space. When a memory access occurs, the hardware checks the EPT tables to find the corresponding mapping to the host‚Äôs physical memory, without requiring the hypervisor to perform this translation manually. Because the EPT hardware can handle memory translations, the number of calls to the hypervisor for address translation is reduced. This minimizes ‚Äúcontext switches‚Äù between the hypervisor and guest OS, improving performance.\nDevice virtualization\rEach child partition represented by a corresponding Virtual Machine Worker Process (VMWP). Running as a user-space process in the root partition, VMWP handles management tasks such as snapshots and migrations. It also emulates certain devices and implements synthetic devices that are not performance-critical. While the user-space implementation offers lower privilege levels for security, it‚Äôs unsuitable for performance-critical tasks like networking and storage. You will find high level overview of the architecture below. If you are not sure, what User Mode/Kernel Mode and Hypervisor modes are for, this wiki article explains it very well.\nVirtualization Service Providers (VSP)\rTo present performance-critical devices to the guest OS, Hyper-V employs Virtualization Service Providers. VSPs are kernel drivers running in the root partition.\nVirtualization Infrastructure Driver (VID)\rThe VID acts as a bridge between the hypervisor and the operating system. It manages virtualization resources, including memory management and CPU scheduling. VID uses the Hypercall interface in order to send management commands to the hypervisor, e.g. partition suspend/resume, partition create/delete, device visibility, e.t.c. It also emulates ROMs.\nWindows Hypervisor Interface Library (WinHv)\rWinHv provides an interface that enables drivers to communicate with the hypervisor using standard Windows calling conventions. It essentially acts as a bridge between an operating system‚Äôs drivers and the hypervisor.\nTypes of Virtual Devices in Hyper-V\rVDev: The Virtual Device\rVirtual Devices, or VDev, represent the virtual hardware stack a Hyper-V VM utilizes. VDev can include various components like network adapters, disk drives, and CPU cores.\nEmulated vs Synthetic Devices\rEmulated Devices: These virtual devices mimic real hardware components and are universally supported by most operating systems. However, they consume more CPU resources due to the emulation process, making them slower.\nSynthetic (Enlightened) Devices: These are optimized for virtualized environments, offering better performance. They communicate directly with the hypervisor via the Virtual Machine Bus (VMBus).\nExample of \u0026ldquo;Enlightened\u0026rdquo; IO shown below. Source ‚Äì old Microsoft Technet article.\nHow VDev Functions\rResource Allocation: When setting up a VM, you can allocate resources by adding various virtual devices managed by VDev.\nDriver Interaction: The guest OS communicates with these virtual devices via drivers. Emulated devices require standard drivers, while synthetic ones need specialized drivers provided by Integration Services (older OSes) or to be already bundled with the OS.\nData Transfer: VDev also oversees data transfer between the guest operating system and virtual devices. For synthetic devices, this happens efficiently through the VMBus.\nThe Virtualization Service Clients (VSC) in child partitions interact with VSPs. The communication is done via VMBus. While modern Windows versions include these kernel drivers for supporting synthetic devices, Linux and FreeBSD also have open-source VSC implementations, enhancing cross-platform compatibility.\nSource: A Dive in to Hyper-V Architecture \u0026amp; Vulnerabilities\nGeneration1 Vs Generation2 Guests\rGen1 is heavily reliant on emulated devices like IDE controllers and legacy network adapters, leading to higher CPU overhead and utilizes legacy BIOS for the booting process.\nGen2 utilizes Unified Extensible Firmware Interface (UEFI) which supports Secure Boot, a feature that helps to prevent unauthorized code execution during the boot process. Uses VMBus directly, resulting in less CPU overhead and better performance and supports booting from a SCSI controller, allowing for larger boot volumes.\nCPU Virtualization\rHyper-V takes advantage of AMD-V and Intel VT-x features to partition physical CPUs into multiple virtual CPUs.\nBoth AMD-V and Intel VT-x are sets of processor extensions that add hardware virtualization support to x86 architecture processors. These technologies facilitate running multiple operating systems on a single physical machine by enhancing the CPU‚Äôs ability to manage and execute multiple instruction sets. Root partition will assign certain logical processors to certain children partitions, those processors called VPs (virtual processors), and the same logical processor on the root partition can be shared between multiple guest os children partitions. Than Hyper-V scheduler implements the scheduling logic, that can be adjusted. Nested virtualization is also available for Hyper-V or Azure Virtual Machines.\nVM Exit Handler\rWhen a virtual machine is running, it occasionally performs operations that the hypervisor needs to intercept for management, safety, or emulation purposes. (e.g. non-maskable interrupts) These could be things like sensitive instructions or privileged operations that a guest VM shouldn‚Äôt execute directly on the host hardware.\nWhen such an operation occurs, a ‚ÄúVM exit‚Äù is triggered, essentially pausing the VM and transferring control to the hypervisor. The VM exit handler is the part of the hypervisor code responsible for dealing with this event. It figures out why the VM exit occurred, performs whatever action is needed (like emulating an instruction or modifying VM state), and then resumes the VM.\nMore?\nIf you want to learn more in depth technical details, I recommend official documentation:\nhttps://learn.microsoft.com/en-us/windows-server/administration/performance-tuning/role/hyper-v-server/architecture\n","description":"How Hyper-V Works, High Level Overview\rHyper-V stands as Microsoft‚Äôs first standalone hypervisor, offering extensive support for the x86-64 architecture. It has established its own space in the virtualization market, going toe-to-toe with competitors like VMware ESXi, Xen, and KVM. One of its distinct advantages is its native integration with Microsoft-centric environments.\nContrary to many Type 2 hypervisors that function atop an existing operating system, Hyper-V is a Type 1 hypervisor that interacts directly with the hardware."},{"id":16,"href":"/tags/hyperv/","title":"Hyperv","parent":"Tags","content":"","description":""},{"id":17,"href":"/SystemAdministration/Cloud/windows-server-azure-vm-in-place-upgrade/","title":"In Place Upgrade Your Windows Server Azure VM: Step by Step Guide","parent":"Cloud","content":"\rIn Place Upgrade Your Windows Server Azure VM: Step by Step Guide\rUpgrading your Windows Server Azure VM to a newer version can seem daunting, but with the right steps, it can be a smooth process. This guide will walk you through a step-by-step process, complete with visuals, to upgrade your Windows VM in Azure, for instance, from WS 2016 to 2019.\nPrerequisites for a Successful Upgrade\rBefore diving into the upgrade, ensure the following prerequisites are met:\nManaged Disk Usage\nYour VM should be using a managed disk. You can verify this via the Azure portal in the JSON view. If your VM isn‚Äôt using a managed disk, you can migrate to one. Volume Licensing Configuration\nYour VM should be set up to use volume licensing as a KMS client. To check this: Within the VM, run the command: slmgr/dlv The description should display: VOLUME_KMSCLIENT channel Sufficient Disk Space\nEnsure that the VM OS drive has ample disk space for an in-place upgrade.\nSnapshot Precaution\nBefore proceeding with the upgrade, take a snapshot of the OS drive. This acts as a safety net, allowing you to roll back if anything goes south.\nUpgrade Process\rSince Azure doesn‚Äôt provide access to the Virtual Machine ISO mounting feature at the hypervisor level, you‚Äôll need to create a managed disk with the upgrade media. Use the following script, sourced from Microsoft‚Äôs official documentation:\n# Login to Azure Connect-AzAccount # Set the subscription context $subscriptionId = \u0026#34;YOUR SUB ID\u0026#34; Set-AzContext -SubscriptionId $subscriptionId # Resource group of the source VM $resourceGroup = \u0026#34;LETSUPGRADE\u0026#34; # Location of the source VM $location = \u0026#34;North Europe\u0026#34; # Zone of the source VM, if any $zone = \u0026#34;\u0026#34; # Disk name for the that will be created $diskName = \u0026#34;WindowsServer2022UpgradeDisk\u0026#34; # Target version for the upgrade - must be either server2022Upgrade or server2019Upgrade $sku = \u0026#34;server2022Upgrade\u0026#34; # Common parameters $publisher = \u0026#34;MicrosoftWindowsServer\u0026#34; $offer = \u0026#34;WindowsServerUpgrade\u0026#34; $managedDiskSKU = \u0026#34;Standard_LRS\u0026#34; # Get the latest version of the special (hidden) VM Image from the Azure Marketplace $versions = Get-AzVMImage -PublisherName $publisher -Location $location -Offer $offer -Skus $sku | sort-object -Descending {[version] $_.Version} $latestString = $versions[0].Version # Create Resource Group if it doesn\u0026#39;t exist if (-not (Get-AzResourceGroup -Name $resourceGroup -ErrorAction SilentlyContinue)) { New-AzResourceGroup -Name $resourceGroup -Location $location } # Create Managed Disk from LUN 0 if ($zone){ $diskConfig = New-AzDiskConfig -SkuName $managedDiskSKU -CreateOption FromImage -Zone $zone -Location $location } else { $diskConfig = New-AzDiskConfig -SkuName $managedDiskSKU -CreateOption FromImage -Location $location } Set-AzDiskImageReference -Disk $diskConfig -Id $image.Id -Lun 0 New-AzDisk -ResourceGroupName $resourceGroup -DiskName $diskName -Disk $diskConfig After running the script, you should see the disk created in the resource group you specified:\nAttach the upgrade disk to the virtual machine. If you‚Äôre unable to view the drive you‚Äôre trying to attach, consider clicking ‚ÄúRefresh‚Äù button on the Disks view:\nConnect to the VM using RDP. You should now see the upgrade disk in the file explorer.\nRun the installer with the following parameters, as recommended by Microsoft: .\\setup.exe /auto upgrade /dynamicupdate disable\nFollow the installer prompts and wait for your system to transition to install mode. This is a good time to take a break or start the installation on another server.\nAfter the RDP session disconnects, monitor the installation progress using Azure boot diagnostics.\nOnce the boot diagnostic displays the login screen:\nReconnect via RDP and confirm the upgrade‚Äôs success by running the winver command.\nPost-Upgrade Cleanup\rDisk Cleanup\nUse the disk cleanup utility to remove the windows.old folder located in the root of your C:\\ drive. Upgrade Media\nDetach the upgrade media and delete the managed disk you created with the script.\nSnapshot\nNow that your upgrade is complete and verified, you can delete the OS disk snapshot you created earlier.\nA Note on Image Plan\rPost-upgrade, you might notice that your Image Plan in the Azure Portal remains unchanged. This is purely cosmetic and reflects the image from which the VM was originally deployed.\nAs you see upgrading the Windows Server Azure VM in place is pretty straightforward process. By following the steps outlined in this guide, you can safely and easily upgrade your VM to a new version. And if you encounter any problems with the upgrade, you can always restore your VM from the snapshot you created before starting the upgrade. You‚Äôve created the snapshot, right? üòâ\n","description":"In Place Upgrade Your Windows Server Azure VM: Step by Step Guide\rUpgrading your Windows Server Azure VM to a newer version can seem daunting, but with the right steps, it can be a smooth process. This guide will walk you through a step-by-step process, complete with visuals, to upgrade your Windows VM in Azure, for instance, from WS 2016 to 2019.\nPrerequisites for a Successful Upgrade\rBefore diving into the upgrade, ensure the following prerequisites are met:"},{"id":18,"href":"/tags/upgrade/","title":"Upgrade","parent":"Tags","content":"","description":""},{"id":19,"href":"/tags/kernel/","title":"Kernel","parent":"Tags","content":"","description":""},{"id":20,"href":"/tags/linux/","title":"Linux","parent":"Tags","content":"","description":""},{"id":21,"href":"/SystemAdministration/Linux/Kernel/softlockup/","title":"Linux Kernel - Deep Dive into Soft/Hard Lockups","parent":"Linux","content":"\rIntroduction\rKernel Watchdog\rAccording to Linux Kernel Documentation, the Linux kernel can act as a watchdog to detect both soft and hard lockups.\nThe Linux Kernel Watchdog is a mechanism that monitors the system for both soft and hard lockups. It is designed to detect when a CPU is stuck in a loop and unable to make progress. When a soft lockup is detected, the watchdog will print a warning message to the system log.\nSoft vs. Hard Lockups\rSoft Lockup\rA ‚Äòsoftlockup‚Äô is defined as a bug that causes the kernel to loop in kernel mode for more than 20 seconds, without giving other tasks a chance to run. The current stack trace is displayed upon detection and, by default, the system will stay locked up.\nBy default the system will display the stack trace and stay locked up. Watchdog can be configured to reboot the system automatically when a soft lockup is detected. This can be done by setting the softlockup_panic parameter to a value greater than zero.\nCommon error messages:\nBUG: soft lockup - CPU#0 stuck for 22s! [swapper/0:1] Modules linked in: ... Hard Lockup\rA ‚Äòhardlockup‚Äô is defined as a bug that causes the CPU to loop in kernel mode for more than 10 seconds, without letting other interrupts have a chance to run.\nSimilar to softlockup, the system will display the stack trace and stay locked up. The watchdog can be configured to reboot the system automatically when a hard lockup is detected. This can be done by setting the hardlockup_panic parameter to a value greater than zero.\nCommon error messages:\nBUG: hard lockup - CPU#0 stuck for 22s! [swapper/0:1] Modules linked in: ... Deep Dive into Soft/Hard Lockups\rReacting to soft/hard lockups\rOk, so you have a soft or hard lockup, what now? Here are some steps you can take to troubleshoot and resolve the issue:\nThe Basics\r1. Check the system logs: Look for any error messages or warnings that may indicate the cause of the lockup.\n2. Check the CPU load: High CPU load can cause lockups. Use tools like top or htop to monitor CPU usage.\n3. Read the watchdog warning message: The watchdog will print a warning message to the system log when a lockup is detected. This message may provide clues as to the cause of the lockup. Usually, the message will include a stack trace that shows where the CPU is stuck, also the name of the process that caused the lockup and it\u0026rsquo;s PID.\nThresholds\rThe watchdog has default thresholds for detecting soft and hard lockups. These thresholds can be adjusted to suit your system\u0026rsquo;s needs. Before changing thresholds, it is important to understand the implications of changing these values. Setting the thresholds too low may result in false positives, while setting them too high may result in missed lockups.\nImplementation\nA periodic hrtimer runs to generate interrupts and kick the watchdog job. An NMI perf event is generated every ‚Äúwatchdog_thresh‚Äù (compile-time initialized to 10 and configurable through sysctl of the same name) seconds to check for hardlockups. If any CPU in the system does not receive any hrtimer interrupt during that time the ‚Äòhardlockup detector‚Äô (the handler for the NMI perf event) will generate a kernel warning or call panic, depending on the configuration. The watchdog job runs in a stop scheduling thread that updates a timestamp every time it is scheduled. If that timestamp is not updated for 2*watchdog_thresh seconds (the softlockup threshold) the ‚Äòsoftlockup detector‚Äô (coded inside the hrtimer callback function) will dump useful debug information to the system log, after which it will call panic if it was instructed to do so or resume execution of other kernel code.\nCheck current threshold:\ncat /proc/sys/kernel/watchdog_thresh 10 Update threshold to 30 seconds:\n# For temporary change echo 30 \u0026gt; /proc/sys/kernel/watchdog_thresh # For permanent change echo \u0026#34;kernel.watchdog_thresh = 30\u0026#34; \u0026gt;\u0026gt; /etc/sysctl.conf sysctl -p Advanced Troubleshooting\rThe watchdog can be configured to panic the system when a lockup is detected. This can be done by setting the softlockup_panic or hardlockup_panic parameters to a value greater than zero.:\n# Enable panic on soft lockup echo 1 \u0026gt; /proc/sys/kernel/softlockup_panic # Enable panic on hard lockup echo 1 \u0026gt; /proc/sys/kernel/hardlockup_panic In combination with crash dump, you can get a full dump of the system state when a lockup is detected. This can be useful for debugging the issue.\nStep-by-step guide for this recipe: 1. Enable crash dump in the kernel configuration. Make sure that it\u0026rsquo;s collecting memory dumps when a kernel panic occurs. 2. Configure the kernel to reboot the system when a lockup is detected. 3. Proceed by analyzing the crash dump to identify the cause of the lockup.\nDemo - Creating a Softlockup and understanding the watchdog output\rSimulating a Soft Lockup\rFor the example below, we will simulate a soft lockup by loading a kernel module design to test if watchdog and lockup detection are working as expected.\nTest module to generate lockups: CONFIG_TEST_LOCKUP\nNote: When installing Linux Kernel modules, make sure: You are using the correct version of the kernel module for your kernel version. (Browse kernel config source code and match your kernel version: Example for v6.9.5). And, that you have the necessary kernel headers installed.\nThe following parameters are available to simulate a variety of lockups:\n# modinfo soft.ko filename: /root/CONFIG_TEST_LOCKUP/soft.ko description: Test module to generate lockups author: Konstantin Khlebnikov \u0026lt;khlebnikov@yandex-team.ru\u0026gt; license: GPL srcversion: 302B4AE69F898F7B25CABF8 depends: retpoline: Y name: soft vermagic: 5.15.0-1064-azure SMP mod_unload modversions parm: time_secs:lockup time in seconds, default 0 (uint) parm: time_nsecs:nanoseconds part of lockup time, default 0 (uint) parm: cooldown_secs:cooldown time between iterations in seconds, default 0 (uint) parm: cooldown_nsecs:nanoseconds part of cooldown, default 0 (uint) parm: iterations:lockup iterations, default 1 (uint) parm: all_cpus:trigger lockup at all cpus at once (bool) parm: state:wait in \u0026#39;R\u0026#39; running (default), \u0026#39;D\u0026#39; uninterruptible, \u0026#39;K\u0026#39; killable, \u0026#39;S\u0026#39; interruptible state (charp) parm: use_hrtimer:use high-resolution timer for sleeping (bool) parm: iowait:account sleep time as iowait (bool) parm: lock_read:lock read-write locks for read (bool) parm: lock_single:acquire locks only at one cpu (bool) parm: reacquire_locks:release and reacquire locks/irq/preempt between iterations (bool) parm: touch_softlockup:touch soft-lockup watchdog between iterations (bool) parm: touch_hardlockup:touch hard-lockup watchdog between iterations (bool) parm: call_cond_resched:call cond_resched() between iterations (bool) parm: measure_lock_wait:measure lock wait time (bool) parm: lock_wait_threshold:print lock wait time longer than this in nanoseconds, default off (ulong) parm: disable_irq:disable interrupts: generate hard-lockups (bool) parm: disable_softirq:disable bottom-half irq handlers (bool) parm: disable_preempt:disable preemption: generate soft-lockups (bool) parm: lock_rcu:grab rcu_read_lock: generate rcu stalls (bool) parm: lock_mmap_sem:lock mm-\u0026gt;mmap_lock: block procfs interfaces (bool) parm: lock_rwsem_ptr:lock rw_semaphore at address (ulong) parm: lock_mutex_ptr:lock mutex at address (ulong) parm: lock_spinlock_ptr:lock spinlock at address (ulong) parm: lock_rwlock_ptr:lock rwlock at address (ulong) parm: alloc_pages_nr:allocate and free pages under locks (uint) parm: alloc_pages_order:page order to allocate (uint) parm: alloc_pages_gfp:allocate pages with this gfp_mask, default GFP_KERNEL (uint) parm: alloc_pages_atomic:allocate pages with GFP_ATOMIC (bool) parm: reallocate_pages:free and allocate pages between iterations (bool) parm: file_path:file path to test (string) parm: lock_inode:lock file -\u0026gt; inode -\u0026gt; i_rwsem (bool) parm: lock_mapping:lock file -\u0026gt; mapping -\u0026gt; i_mmap_rwsem (bool) parm: lock_sb_umount:lock file -\u0026gt; sb -\u0026gt; s_umount (bool) We will simulate a soft lockup by loading the module with the following parameters:\ninsmod soft.ko time_secs=35 iterations=1 all_cpus=0 state=\u0026#34;R\u0026#34; Where:\ntime_secs=35 - Lockup time in seconds iterations=1 - Lockup iterations all_cpus=0 - Trigger lockup at all CPUs at once state=\u0026quot;R\u0026quot; - Wait in \u0026lsquo;R\u0026rsquo; running state After loading the module, the system will be locked up for 35 seconds. The watchdog will detect the soft lockup and print a warning message to the system log.\nUnderstanding the watchdog output\rThe watchdog warning message\r[ 568.503455] watchdog: BUG: soft lockup - CPU#1 stuck for 26s! [insmod:5912] [ 568.508018] Modules linked in: soft(OE+) nls_iso8859_1 kvm_intel kvm crct10dif_pclmul crc32_pclmul ghash_clmulni_intel binfmt_misc sha256_ssse3 sha1_ssse3 aesni_intel crypto_simd cryptd joydev hid_generic serio_raw hyperv_drm drm_kms_helper syscopyarea hid_hyperv sysfillrect sysimgblt hid fb_sys_fops hv_netvsc hyperv_keyboard cec rc_core sch_fq_codel drm i2c_core efi_pstore ip_tables x_tables autofs4 The watchdog warning message includes the following information:\nBUG: soft lockup - Indicates that a soft lockup was detected CPU#1 stuck for 26s! - Indicates that CPU#1 was stuck for 26 seconds [insmod:5912] - Indicates that the process with PID 5912 caused the lockup (in this case, the insmod process) Modules linked in (...) - Lists the kernel modules that were loaded at the time of the lockup The stack trace\r[ 568.508074] Call Trace: [ 568.508075] \u0026lt;IRQ\u0026gt; [ 568.508079] ? show_regs.cold+0x1a/0x1f [ 568.508085] ? watchdog_timer_fn+0x1c4/0x220 [ 568.508089] ? softlockup_fn+0x30/0x30 [ 568.508092] ? __hrtimer_run_queues+0xca/0x1d0 [ 568.508095] ? hrtimer_interrupt+0x109/0x230 [ 568.508097] ? hv_stimer0_isr+0x20/0x30 [ 568.508101] ? __sysvec_hyperv_stimer0+0x32/0x70 [ 568.508104] ? sysvec_hyperv_stimer0+0x7b/0x90 [ 568.508109] \u0026lt;/IRQ\u0026gt; [ 568.508110] \u0026lt;TASK\u0026gt; [ 568.508111] ? asm_sysvec_hyperv_stimer0+0x1b/0x20 [ 568.508116] ? delay_tsc+0x2b/0x70 [ 568.508118] __const_udelay+0x43/0x50 [ 568.508122] test_wait+0xc6/0xe0 [soft] [ 568.508129] test_lockup+0xd9/0x270 [soft] [ 568.508133] test_lockup_init+0x891/0x1000 [soft] [ 568.508137] ? 0xffffffffc084f000 [ 568.508139] do_one_initcall+0x48/0x1e0 [ 568.508143] ? __cond_resched+0x19/0x40 [ 568.508146] ? kmem_cache_alloc_trace+0x15a/0x420 [ 568.508150] do_init_module+0x52/0x230 [ 568.508154] load_module+0x1294/0x1500 [ 568.508159] __do_sys_finit_module+0xbf/0x120 [ 568.508162] ? __do_sys_finit_module+0xbf/0x120 [ 568.508165] __x64_sys_finit_module+0x1a/0x20 [ 568.508168] x64_sys_call+0x1ac3/0x1fa0 [ 568.508170] do_syscall_64+0x54/0xb0 [ 568.508174] ? __audit_syscall_exit+0x265/0x2d0 [ 568.508177] ? ksys_mmap_pgoff+0x14b/0x2a0 [ 568.508182] ? exit_to_user_mode_prepare+0x54/0x270 [ 568.508185] ? syscall_exit_to_user_mode+0x27/0x40 [ 568.508187] ? do_syscall_64+0x61/0xb0 [ 568.508189] entry_SYSCALL_64_after_hwframe+0x67/0xd1 [ 568.508191] RIP: 0033:0x7f860d3fa95d [ 568.508194] Code: 00 c3 66 2e 0f 1f 84 00 00 00 00 00 90 f3 0f 1e fa 48 89 f8 48 89 f7 48 89 d6 48 89 ca 4d 89 c2 4d 89 c8 4c 8b 4c 24 08 0f 05 \u0026lt;48\u0026gt; 3d 01 f0 ff ff 73 01 c3 48 8b 0d 03 35 0d 00 f7 d8 64 89 01 48 [ 568.508196] RSP: 002b:00007ffd21043e88 EFLAGS: 00000246 ORIG_RAX: 0000000000000139 [ 568.508198] RAX: ffffffffffffffda RBX: 0000562af1c447d0 RCX: 00007f860d3fa95d [ 568.508199] RDX: 0000000000000000 RSI: 0000562af1c442a0 RDI: 0000000000000003 [ 568.508200] RBP: 0000000000000000 R08: 0000000000000000 R09: 00007ffd21044048 [ 568.508201] R10: 0000000000000003 R11: 0000000000000246 R12: 0000562af1c442a0 [ 568.508202] R13: 0000000000000000 R14: 0000562af1c447a0 R15: 0000562af1c442a0 [ 568.508204] \u0026lt;/TASK\u0026gt; [ 577.859869] soft: Finish on CPU1 in 34727950300 ns [ 577.859874] soft: FINISH in 34727963600 ns The stack trace shows where the CPU was stuck and provides information about the process that caused the lockup.\nImportant information from the stack trace:\nIRQ - Indicates that the CPU was in an interrupt context when the lockup occurred. TASK - Indicates what calls where being executed when the lockup occurred. When comparing with source code, you can identify the function that caused the lockup. In this case, the test_wait function in the soft module caused the lockup.\ntest_lockup.c\nstatic void test_wait(unsigned int secs, unsigned int nsecs) { if (wait_state == TASK_RUNNING) { if (secs) mdelay(secs * MSEC_PER_SEC); if (nsecs) ndelay(nsecs); return; } __set_current_state(wait_state); if (use_hrtimer) { ktime_t time; time = ns_to_ktime((u64)secs * NSEC_PER_SEC + nsecs); schedule_hrtimeout(\u0026amp;time, HRTIMER_MODE_REL); } else { schedule_timeout(secs * HZ + nsecs_to_jiffies(nsecs)); } } Why did it hang?\rThe test_wait function was waiting in the TASK_RUNNING state, which caused the CPU to be stuck in a loop. The mdelay function was used to delay the execution of the function for a specified number of milliseconds. In this case, the function was delayed for 35 seconds, which caused the lockup. Final Thoughts\rThe Linux Kernel Watchdog is a powerful tool for detecting soft and hard lockups. By understanding how the watchdog works and how to react to lockups, you can troubleshoot and resolve issues more effectively. Remember to check the system logs, CPU load, and watchdog warning messages when a lockup occurs. By following best practices and using advanced troubleshooting techniques, you can identify the root cause of lockups and take steps to prevent them in the future.\n","description":"Introduction\rKernel Watchdog\rAccording to Linux Kernel Documentation, the Linux kernel can act as a watchdog to detect both soft and hard lockups.\nThe Linux Kernel Watchdog is a mechanism that monitors the system for both soft and hard lockups. It is designed to detect when a CPU is stuck in a loop and unable to make progress. When a soft lockup is detected, the watchdog will print a warning message to the system log."},{"id":22,"href":"/tags/watchdog/","title":"Watchdog","parent":"Tags","content":"","description":""},{"id":23,"href":"/SystemAdministration/Linux/linuxrebootcheck/","title":"Linux Reboot Quick Analyzer","parent":"Linux","content":"\rWhat is Linux Boot/Shutdown Quick-Analyzer and why do you need it?\rThe Linux Boot/Shutdown Quick-Analyzer is a Python script that analyzes Linux boot and shutdown logs.\nIt makes it easy to find boot and shutdown events in system logs, providing information such as the number of boot and shutdown events, along with the timestamp, filename, and line number for each event.\nHow to run it\rYou need to have Python 3 installed on your machine.\nTo use the script, navigate to the directory containing your logs (usually /var/log) and run the following command:\n# Make sure you are working inside your system logs dir cd /var/log # Exucute the script curl https://raw.githubusercontent.com/samatild/linuxrebootcheck/main/linuxrebootcheck.py | python3 Special arguments for special Serial Console logs!\rWhat about those logs that are not in the usual format?\nTo analyze Serial Console file, you need to download the script and use the \u0026ndash;serial-console-log argument followed by the filename:\ncurl -O https://raw.githubusercontent.com/samatild/linuxrebootcheck/main/linuxrebootcheck.py python3 linuxrebootcheck.py --serial-console-log \u0026lt;your_log_file\u0026gt; Conclusion\rOverall, the Linux Boot/Shutdown Quick-Analyzer is a useful tool for analyzing Linux boot and shutdown logs. It provides a quick and easy way to find boot and shutdown events in system logs, making it easier to troubleshoot issues and identify potential problems. If you\u0026rsquo;re looking for a simple and efficient way to analyze your system logs, give it a try!\nSource\rüîó samatild/linuxrebootcheck\n","description":"What is Linux Boot/Shutdown Quick-Analyzer and why do you need it?\rThe Linux Boot/Shutdown Quick-Analyzer is a Python script that analyzes Linux boot and shutdown logs.\nIt makes it easy to find boot and shutdown events in system logs, providing information such as the number of boot and shutdown events, along with the timestamp, filename, and line number for each event.\nHow to run it\rYou need to have Python 3 installed on your machine."},{"id":24,"href":"/tags/python/","title":"Python","parent":"Tags","content":"","description":""},{"id":25,"href":"/","title":"Softlockup","parent":"","content":"\rWhere IT Wizards Find Their Spells\rSoftlockup provides comprehensive documentation on a wide range of IT topics, including but not limited to system administration, networking, cybersecurity, and software development. Our goal is to create an open and collaborative platform where IT engineers can find and share knowledge.\nLatest Articles\r","description":"\rWhere IT Wizards Find Their Spells\rSoftlockup provides comprehensive documentation on a wide range of IT topics, including but not limited to system administration, networking, cybersecurity, and software development. Our goal is to create an open and collaborative platform where IT engineers can find and share knowledge.\nLatest Articles\r"},{"id":26,"href":"/authors/","title":"Authors","parent":"Softlockup","content":"","description":""},{"id":27,"href":"/authors/John-Doe/","title":"John Doe","parent":"Authors","content":"I\u0026rsquo;m jhon doe\n","description":"I\u0026rsquo;m jhon doe"},{"id":28,"href":"/categories/","title":"Categories","parent":"Softlockup","content":"","description":""}]